## ✅DCT 방법

- 변환 부호화 방법 중 가장 많이 쓰이는 방법

### Fourier 변환, FFT(Fast Fourier Transform) 방법

- cos 함수를 기반으로 주기가 다양한 cos 함수들을 조합하는 원리
- 이 퓨리에 변환 같은 경우에는 cos뿐만 아니라 sin 함수의 조합도 사용
- JPEG 압축 알고리즘에서 DCT 변환을 사용

### FDCT 방법

![](https://velog.velcdn.com/images/kansun12/post/5d483723-d1eb-4256-8941-ab783a06dc7c/image.png)

- f(i, j)는 영상의 공간 좌표계상의 x축, y축
- F(u, v)는 DT변환 후에 부호화된 영상
- cos 함수의 주기가 빈번하게 올라갔다 내려갔다하는게

> 즉, **cos 함수의 주기에 따라** 영상의 **`고주파 저주파`**로 표현
cos 관점에서의 주파수 영역으로 변환하는 부호화 방법을 **`FDCT`**라고 함.

### IDCT 방법

![](https://velog.velcdn.com/images/kansun12/post/1fb6caef-83e1-4206-9a61-682c10f6ca20/image.png)

- 근데 반대로 주파수 변환 후 공간영역으로 영상 변환 방법을 **`Inverse DCT`** 라고 함.

---

![](https://velog.velcdn.com/images/kansun12/post/dae3d49c-d368-4aa5-9232-f284a00ac080/image.png)

- 전방향에 대해서 A16이 가장 고주파적 성분을 지니고 있음.
- 4 X 4 에 대해서 표현 가능한 모든 조합은 16개이고 이걸 “기저”라고 한다.
- 이 16개의 기저들에다가 a1, a2, a3…..a16까지의 계수들을 다 곱하면  맨 왼쪽의 그림을 완성할 수 있다는 것이다.

### 기저와 cos의 상관관계

- 각 기저들이 cos 함수의 모양으로 표현가능해짐.

### DCT 변환

![](https://velog.velcdn.com/images/kansun12/post/d0477493-1dc7-426e-8b2c-98fd578864ce/image.png)

- 맨 왼쪽 위 부분이 `저주파 영역`, 바깥으로 나갈수록 `고주파 영역`
- `DC` : 영상의 평균 밝기 즉, **DC level**

  ![](https://velog.velcdn.com/images/kansun12/post/29173746-ed3f-4fa3-afca-5f4bac806c44/image.png)

    - JPEG 압축의 경우 8X8 단위로 영상을 DCT 변환해서 압축을 함.
    - 64개의 기저들의 선형결합, 계수들을 곱하고 더하는 것을 통해서 8X8로 표현할 수 있는 어떤 영상이든지 다 나타낼 수 있음.
    - 128X128사이즈일 경우에는 기저 함수가 너무 많이 쓰이니까 오래걸려서 8X8 단위로 쪼개서 DCT 변환으로  합축함.

---

## 양자화

- DCT 변환된 결과 테이블을 양자화 테이블로 나눈 것을 **`양자화`**
- 다시 곱해서 원상복귀 시키는 것을 `역양자화` 라고 함
- 양자화 : $F^ϱ (u,ν)=round((u,ν))/(ϱ(u,ν)))$
- 역양자화 : $R(u,ν)=F^ϱ (u,ν)×ϱ(u,ν)$

![](https://velog.velcdn.com/images/kansun12/post/599c198b-9c3f-445d-956b-0ab2efc8b66b/image.png)

- **`Luminance Blocks`**는 영상의 밝기에 대한 양자화 테이블
    - **밝기 정보**에 대해서는 많이 보존
- **`Chrominance Blocks`**는 색상 성분에 대한 양자화 테이블 :
    - **색상정보**에 대해서는 조금만 보존하고 나머지는 0으로 만듦

> 그래서 **YCbCr 모델**에서 `Y`에 해당하는 것은 `루미넌스 테이블`로 나눠주고 `CbCr`은 `크로미넌스 테이블`로 나눠준다.

- *JPEG 양자화 시 Y하고 CbCr 요소에 양자화 테이블이 왜 다른가*

  → **사람의 눈이 밝기보다는 색상에 더 둔감하기 때문임.**

- **색상 정보에 대한 고주파 성분을 제거해도 변화를 파악하기 어려움**

---

### 양자화 과정(JPEG 알고리즘의 원리)

![](https://velog.velcdn.com/images/kansun12/post/8da66c55-8dc5-44b2-b33c-d0553c12b950/image.png)

- 첫번째가 실제 영상이 가지고 있는 화소 값
- 두번째 FDCT를 거친 후에는 좌측 상단만 굉장히 큰 값을 가지고 있음.
- 세번째, 양자화 하기 두번째에서 작은 값들은 죄다 0으로 만들어버리는거임.

—> 여기까지가 압축을 하는 과정

- 아까는 양자화 테이블로 나눠줬으니 다시 되돌리려면 양자화 테이블을 다시 곱하면 됨.
- 곱했을 때는 약간의 오차가 발생하고 0에서 곱해줘도 0이니 0이 된 값들은 복원을 할 수가 없음.
- 그러고 IDCT를 하면 원래 영상의 화소값을 다시 얻을 수 있다.

---

## 차분부호화(Differential Encoding)

![](https://velog.velcdn.com/images/kansun12/post/99219a4b-ffa7-492d-ab19-3edd1c97f57f/image.png)

- 서로 인저반 값들끼리의 차이 값만 저장, **`1 차 미분값을 저장`**
- 차분부호화가 이렇게 사용될 수 있는 이유는 **Locality 원칙**에 의해 차분 부호화를 효과적으로 사용 가능하기 때문.
    - **`Locality`** : 인접한 값이 비슷할거라는 가정ㅇ을 가지고 있음.
    - **시간의 흐름**에 따라서도 큰 차이가 없다.

![](https://velog.velcdn.com/images/kansun12/post/9973182b-ed61-4719-b788-b7d805e9f65b/image.png)

- 아날로그 신호가 들어오면 샘플링을 하고 , 양자화를 해야 함. → 그 양자화된 형태를 비트 형태로 만든 후 이진비트 형태로 표현
- **Sampling** 된 것 : `PAM 펄스`
- 양자화까지 된 코드 : `PCM 펄스`

![](https://velog.velcdn.com/images/kansun12/post/95296570-aecf-4009-86cc-4a89327968a4/image.png)

- 아날로그 신호
    - 이 신호를 몇개의 간격으로 쪼갤 것인지 계산하는 것을 Sampling Rate라고 함.

  ![](https://velog.velcdn.com/images/kansun12/post/6bb5658d-a5e6-44be-83eb-60daaf8ade71/image.png)

    - 이렇게 **3 bits로 표현**한느 것이 **`양자화(8단계)`**
    - 이 과정에서 **데이터 손실**이 발생하게 되는 것임.

  → 그래서 **양자화 레벨의 디테일의 차이가 중요한 것**

  → 저 PCM 펄스를 일렬로 쭉 나열하면→ **`001100100010111010011011111`**


![](https://velog.velcdn.com/images/kansun12/post/8a98ed08-77fe-4064-a70c-2193baf20f0b/image.png)

- 값을 그냥 이진수로 바로 표현해서 나타내는 것을 PCM이라고 했다면 **이 값들을 1차 미분으로 차분 값을 구한 후 이진수로 표현해서 나열한 것**을 **DPCM** 이라고 한다.

![](https://velog.velcdn.com/images/kansun12/post/77b62e40-1f33-4f06-98cc-0ecb8e8c8875/image.png)

- 차분한 DPCM 표본을 보면 `양수는 1`로 시작하게, `음수는 0`으로 시작하도록 매핑했다.
- 그런데! 제일 상위 비트를 부호 비트를 쓰다보니 첫번째 비트는 음수, 양수 구분하기 위해 쓰고 나머지 두개의 비트밖에 사용이 안되는 것 → 두 개 비트로 표현할 수 있는 값은 “3”까지 가능함.. 근데 **4,-4가 나옴..**

> **즉 표현할 수 있는 제일 큰 값과 작은 값으로 덮어버리게 됨. 이렇게 하면 나중에 이 코드로 신호를 복원 했을 때 4가 3으로, -4가 -3으로 표현이 되어 버려 복구 시에 오류가 발생하게 됨**

> Amplitude PCM을 그대로 표현하는게 아니라 차분값만 표현
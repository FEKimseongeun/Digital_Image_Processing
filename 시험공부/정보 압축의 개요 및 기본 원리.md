- **데이터 압축이 필요한 이유**
    - 압축을 하지 않으면 저장하거나 데이터 전송 시에 문제가 발생함.
- **압축의 종류**
    - `무손실 압축` : 데이터 손실이 전혀 없는 무손실 압축
    - `손실 압축` : 사람이 눈치 채지 못하는 정보를 버려서 압축하는 손실 압축
- **압축률**: 원시 자료량(원래 데이터 크기) / 압축된 자료량(압축된 데이터 크기)
- 압축 시 압축을 할 때와 풀 때의 **시간**을 고려해야 함. → **알고리즘 복잡도와 연결**
    - **자원의 가용성**을 고려해야 함
    - **표준화 기법**도 고려해야 함

> `압축` : **Encoding**
`압축 해제` : **Decoding**
>

![](https://velog.velcdn.com/images/kansun12/post/4bc518b8-3dda-4062-aa73-c0f050b96611/image.png)

![](https://velog.velcdn.com/images/kansun12/post/709f53a9-0bb1-422c-9839-c9997798b737/image.png)

- 위 이미지를 보면 알겠지만 비트가 다르게 설정이 되어 있는데도 불구하고 **사람 눈은 색에 둔감해서** 뭐가 다른지 잘 파악하지 못함
- 소리도 마찬가지로 사람 귀에 들리지 않는 부분이 있어서 사람 귀에 들리는 대역(**가청 주파수대역)이 아닌 경우** **`(손실)Lossy 압축`**을 사용할 수 있다는 것
- 사운드같은 경우에는 동일한 주파수대역이 있으면 하나의 소리가 다른 소리를 묻기도 함.(마스킬 효과ㅏ)
    - 예를 들어 공장에 들리는 소음을 묻기 위해서 **그와 유사한 주파수 대역의 소리를 틀어놓아 소음을 `상쇄`** 시킬 수도 있다고 함.

> 즉, 손실 압축은 시각, 청각 적인 부분을 역으로 이용해서 압축을 하는 방법임.

- **높은 공간 주파수** : `밝기값 변화량 **많음**`
- **낮은 공간 주파수** : `밝기값 변화량 **적음**`

- 저주파라는 것은 화소값이 거기서 거기라는 의미이니 그걸 다 일일이 8bit 256 level로 저장할 필요 없이 비슷한 화소들은 그 차이만을 저장하는 방법으로 크기를 줄일 수 있음.

> **이웃한 화소 밝기 값이 유사 →예측 가능한 공간적 정보를 제거 → 데이터양을 줄임.**

### 공간 주파수에 대한 사람의 일상 예

- 예를 들어 직장인은 월요일 부터 금요일 까지 루틴이 똑같은데 굳이 스케ㅔ쥴을 작성할 때 일일이 월요일, 화요일,,,, 을 적을 필요가 없음 → “월~금요일은 직장 출퇴근”이라고 적으면 되는 것

→ 이것은 즉, **월요일부터 금요일 까지는 상관성이 높음**

> **상관성이 높음 → 압축률 높음**

![](https://velog.velcdn.com/images/kansun12/post/217d6193-59c1-467f-89c7-0bc9d6d500bc/image.png)

초반에 밝기 값이 높게, 일정하게 진행된 것을 볼  수 있는데 이는 밝기 값이 비슷한 영역이라 그렇고 이를 **`저주파 영역`**이라고 함. 밝기 값이 크게 변하는 영억은 **`고주파 영역`**

> **저주파 성분 데이터는 압축률이 좋음 = 원본 데이터 사이즈가 거의 유사하게 유지가 된다.**

- 비슷비슷한 데이터들은 중복성을 제거하는 기본 원리가 됨.
- **소리 증폭 압축의 예시**

  ![](https://velog.velcdn.com/images/kansun12/post/7d114790-cbee-4c57-b8e6-998d1af1e223/image.png)

  ![](https://velog.velcdn.com/images/kansun12/post/6124ca81-bd78-4f95-8999-d91955370b71/image.png)

    - **각 소리 증폭의 차이를 나타낸 것**

  → 이렇게 이전 값과의 차이를 저장하는 것이 **`미분개념`**

- 이렇게 8단계의 값을 표현할 경우 **3개의 비트**가 필요
- 차분 값을 저장할 때에는 **2개의 비트**가 필요 → 이렇게 하면 데이터 사이즈가 2/3 사이즈로 줄어듦

---

> 이렇게 영상도 **`차분값`**을 저장함으로써 **데이터 크기를 줄일 수 있음.**

![](https://velog.velcdn.com/images/kansun12/post/f5ac2893-ca4e-47a6-8cb7-647571806afc/image.png)

- 이런식으로 저주파 영역의 차분값을 저장하면 까맣게 나옴

![](https://velog.velcdn.com/images/kansun12/post/38baec33-fb7c-418d-a9fb-6d7ad4528dd8/image.png)

![](https://velog.velcdn.com/images/kansun12/post/08ece4a4-853e-4e93-8962-172c5f4ce262/image.png)

- 위 영상의 히스토그램을 그려보면 **`0을 기준으로 가우시안 분포`**를 이루는 것을 볼 수 있다.
- 원 영상의 히스토그램과는 확실히 다르고 더 데이터양을 줄임. 디테일한 것을 줄임

> **결론적으로, 미분개념을 사용하면 데이터 압축을 효율적으로 할 수 있음**

---

![](https://velog.velcdn.com/images/kansun12/post/c32aa86f-2bb0-4f78-b9f7-3a1c400a9762/image.png)

세 프레임이 순서대로 나온다고 했을 때 사실상 세 프레임의 차이가 별로 없음 → 사람이 움직이고 있는 구역에서만 차이가 나타남.

![](https://velog.velcdn.com/images/kansun12/post/d5d44fa0-5cbc-440c-9ae3-d6a6e7744e6f/image.png)

- 저런식으로 움직였을 때 발생하는 **`시간적 차이만 효율적`**으로 저장하는 거임.
- 그래서 나중에 압축된 것을 디코딩 할 때에는 움직이는 부분만 가져와서 그 프레임을 다시 만들어내는 것임 → 결국에는 **압축하기 전후 차이가 없음**

> **즉, 움직이는 양에 대한 부분만 저장을하고 저장을 해도 압축하기 전 영상과 거의 동일하게 압축할 수 있다.**
>
- 문제점
    - 이렇게 압축을 하면서 프레임을 다시 만들어내다보니 **`불연속`**이 발생하기도 함.
    - 이것은 정방향으로 영상을 쪼개서 블록 단위로 압축을 진행하기 때문에 발생함.
    - 그래서 **JPEG 압축의 경우에도** 너무 많이 압축을 할 경우 **`Blcoking Effect`**가 나타남.

### 정보압축에서도 딥러닝 방법을 사용할 수 있을까?

- 영상 기하 변환 같은 것을 할 때 영상을 확대하는 부분에서 홀이나 오버랩 같은 문제가 생겼었던 것을 볼 수 있는데 그 빈 부분을 채우기 위해서 Interpolation 방법을 사용했음
- 최근에는 확대 후 비어 있는 부분을 Super resolution이라는 방법이 나타났음
- 이건 한 장의 저해상도 영상이 주어지면 이 영상을 단순히 확대시키는 것이 아니라 확대를 해가지고 비어있는 부분에 대해서 Interpolation 하는 이슈를 딥러닝 방법을 쓸 수 있다는 것임.
- 그렇게 했을 때 **저해상도 영상만 있어도 고해상도 영상을 만들 수 있음.**

---

# 기본 정보 기술과 압축 기술의 원리

- 기본적인 정보 이론

  $Entropy, H = - \sum_{i = 1}^{n}{P_ilog_2P_i}$

    - `Entropy` (소스의 정보량)를 계산하는 방법 : 데이터가 중복되어 있는 부분을 제외하고 순수하게 가지는 정보량
    - `N` :  정보의 종류의 개수
    - `P` : 확률
    - log로 인해서 계산 결과가 음수로 나오기 때문에 마지막에 음수를 붙여 **양수의 결과**를 얻게 된다.
- **`상관성(예측가능성)이 높으면 압축률이 좋다고 했음`** : 모든 정보에 대해서 일일이 다 표현할 필요가 없다.

![](https://velog.velcdn.com/images/kansun12/post/95c943e7-021c-4d7c-a413-d0f7b469c0d2/image.png)

- 상관성이 클수록 Entropy가 낮음
- 어떤 특정 데이터가 전체 데이터에서 굉장히 잦은 비율로 등장을 한다 → Entropy가 낮음

### 예제1

![](https://velog.velcdn.com/images/kansun12/post/f582cdf1-58e2-4f20-9c44-91798ab7c582/image.png)

- 오른쪽 리스트 처럼 **비트의 길이를 서로 다르게 부호화하는 것**을 **`가변길이 부호화`**라고 함

→ **발생 빈도가 높을 경우 잛은 길이의 부호를 할당해야함**

**Q. 문자 당 평균 비트수**

A. $\sum_{i=1}^{6}{N_iP_i}$ = (2(2 x 0.25) + 4(3 x 0.125)) = **2.5**

→ **문자 하나 당** 평균 **2.5비트**가 할당된다는 의미

**Q. 문서의 엔트로피**

A. $\sum_{i=1}^{6}{P_ilog_2P_i}$ = -(2( 0.25$log_2$0.25 ) + 4(0.125 $log_2$0.125)) = 2.5

**Q. 고정길이의 이진 부호화 시 최소 비트 수**

A. 6개의 다른 문자를 구분해야 하므로 3비트(8종류 표현 가능)가 필요

> **결론 : 고정길이에서 필요한 비트 수 는 3비트였는데 가변 길이로 했을 때는 2.5비트만 필요
데이터 개수가 5/6로 줄어들게 됨.
그래서 가변길이로 했을 때 엔트로피에 거의 비슷했으니 이 데이터에 가변길이 코드를 제대로 할당한거라고 볼 수 있다.**

---

### 통계적 중복성 제거

- 자주 등장하는 애(**확률이 높을 수록**)에 대해서는 **`짧은 길이`**의 부호를 할당
- 덜 등장하는 애(**확률이 낮을 수록**)에 대해서는 **`긴 길이`**의 부호를 할당

### 엔트로피 부호화 방식

- 가변길이의 부호에 할당할 수 있는 방법이 뭐가 있을까
    - **`허프만 부호화`**
    - **`산술 부호화`**

## 다시 정리하는 압축의 기본 원리

> **빛 보다 색**에, **저주파보다 고주파**에 **더 둔감함**에 따른 압축원리.
비슷한 화소의 **차분 값에 저장공간을 할당하지 않는** **공간적인 중복성을 제거**하는 것.
**차분 신호**를 구해서 **양자화 레벨**을 줄이는 **시간적 중복성을 제거**
데이터들 중에 **자주 등장**하는 애들과 **덜 등장**하는 애들을 바탕으로 **가변적으로 부호화**하므로서 **통계적 중복성을 제거**
>

---

# 압축 알고리즘 분류
![](https://velog.velcdn.com/images/kansun12/post/31befffd-99f6-4c2d-86c3-2ceb4c7cdc2f/image.png)

- **엔트로피 압축 같은 경우 결과적으로 손실이 없음**
- 사람의 시청각적 맹점을 이용한 압축이 일반적으로 손실 압축 방법을 따름

---

# 런 - 길이 부호화 (Run-Length Encoding)

![](https://velog.velcdn.com/images/kansun12/post/a3ada937-2ba3-4a72-9b8c-4cdcbc74072d/image.png)

- 그 문자가 나오는 반복 회수를 기록함으로써 **`데이터의 길이를 압축`**
- 인코딩한 것을 **디코딩** 시 그대로 복원 가능한 **`무손실 압축`**

### 예시

![](https://velog.velcdn.com/images/kansun12/post/84368dd4-17ae-43b8-8800-57d7c467568d/image.png)

- 문서 같은 경우 압축 후가 전보다 큼 → **`상관성이 거의 없는 경우에 해당`**
    - 즉 **문서파일 압축에는 run-length가 부적합**
- 이미지 같은 경우에는 **run-length 인코딩이 적합함.**

### 런 - 길이 부호화의 단점

![](https://velog.velcdn.com/images/kansun12/post/e4c0983d-e48a-49eb-89f6-623cf33382eb/image.png)

- 반복되어서 나오는 문자열이 하나도 없게 되니까 일일이 하나씩 저장되면서 크기가 커짐

---

## 허프만 부호화

- 가변길이 부호화의 대표적인 예시

![](https://velog.velcdn.com/images/kansun12/post/a13c9dad-b12f-4c6f-976e-3edfe4e0affb/image.png)


- **더 자주 등장하는 것은 짧은걸로 할당하고 덜 등장하는 것은 긴걸로 할당**

![](https://velog.velcdn.com/images/kansun12/post/d6ded463-9edf-481a-8a1e-3edd1e362e1b/image.png)

- s0 : `0` / s1: `10` / s2: `110` / s3: `111`
- 데이터 종류가 4개인 경우 2개의 비트가 필요 → 근데  50% 등장하는 애한테는 비트를 하나만 쓰고 30%에는 2개,  10%씩 등장하는 애한테는 3개.

![](https://velog.velcdn.com/images/kansun12/post/42f758b0-9e74-4474-9e92-6ad6bb4c9767/image.png)

> **결과적으로 따져보면 고정 길이로 하면 2bit를 써야하지만 가변 길이로 할 경우 1.75bit만 사용한다는 것이니 7/8수준으로 압축되었다고 볼 수 있음.**

- **이 허프만 코드 방식은 현재 사용 되는 대부분의 압축기법에 이용되고 JPEG 압축 알고리즘에도 허프만 코딩을 이용해서 가변길이 부호화하는 부분이 있음.**